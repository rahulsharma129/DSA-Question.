include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int n=grid.size();
        if(grid[0][0]==1) return -1;
        if(grid[0][0]==0 and n==1) return 1;
        
        queue<pair<int,int> >q;
        int level=0;
        q.push({0,0});
        grid[0][0]=1;
        vector<vector<int>>dir={{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1}};
        while(!q.empty()){
            int sz=q.size();
            while(sz--){
                auto curr =q.front();
                q.pop();
                int x=curr.first;
                int y=curr.second;
                if(x==n-1 and y==n-1) return level+1;
                for(int i=0;i<8;i++){
                    int nx=x+dir[i][0];
                    int ny=y+dir[i][1];
                    if(nx>=0 && ny>=0 && nx<n && ny<n && grid[nx][ny]==0){
                        grid[nx][ny]=1;
                        q.push({nx,ny});
                        
                    }
                }

            }
            level++;
        }
        return -1;

    }
};
..................................................................................................


class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (!root) return NULL;
        if (root->val == key) return helper(root);

        TreeNode* dummy = root;
        while (root) {
            if (root->val > key) {
                if (root->left && root->left->val == key) {
                    root->left = helper(root->left);
                    break;
                } else {
                    root = root->left;
                }
            } else {
                if (root->right && root->right->val == key) {
                    root->right = helper(root->right);
                    break;
                } else {
                    root = root->right;
                }
            }
        }
        return dummy;
    }

    TreeNode* helper(TreeNode* root) {
        if (!root->left) return root->right;
        if (!root->right) return root->left;

        TreeNode* rightChild = root->right;
        TreeNode* lastRight = findLastRight(root->left);
        lastRight->right = rightChild;
        return root->left;
    }

    TreeNode* findLastRight(TreeNode* root) {
        if (!root->right) return root;
        return findLastRight(root->right);
    }
};